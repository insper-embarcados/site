


# I2C

## Introdução ao I2C
O I2C (Inter-Integrated Circuit) é um protocolo de comunicação serial síncrona que permite a comunicação entre microcontroladores e dispositivos periféricos utilizando apenas duas linhas: uma linha de dados **SDA** (Serial Data Line) e uma linha de clock **SCL** (Serial Clock Line). Ele foi desenvolvido pela Philips Semiconductor (atualmente NXP Semiconductors) nos anos 80.



## Topologia

Para usar o I2C, é necessário conectar os dispositivos em uma infraestrutura de barramento, geralmente utilizando resistores de pull-up na linha de dados (SDA) e na linha de clock (SCL). O sinal de clock (SCL) é sempre gerado pelo "mestre", que é o dispositivo que inicia e controla as comunicações. O sinal de dados (SDA) pode ser manipulado tanto pelo "mestre" quanto pelo dispositivo com o qual ele está se comunicando.



![I2C-Components-with-pull-up-resistors](imgs\I2C-Components-with-pull-up-resistors.png)

É possível conectar um único mestre a vários dispositivos em paralelo, formando uma topologia conhecida como "varal". Para possibilitar essa conexão, cada dispositivo é identificado por um endereço de 7 bits único.



## Protocolo

A comunicação no protocolo I2C é baseada em transações de mestre e escravo. O dispositivo mestre inicia e controla as comunicações, enquanto os dispositivos escravos respondem às solicitações do mestre. Abaixo disponibilizo uma visão geral do protocolo

1. **Start Condition**: A comunicação no barramento I2C é iniciada por uma condição de início (start condition), na qual o mestre coloca o sinal SDA de nível alto para baixo enquanto o sinal SCL permanece em alto.

2. **Endereçamento**: O mestre transmite o endereço do dispositivo com o qual deseja se comunicar. Cada dispositivo no barramento possui um endereço único de 7 ou 10 bits. O bit seguinte indica se o mestre está escrevendo (0) ou lendo (1) dados do dispositivo.

3. **Acknowledge (ACK)**: Após o recebimento do endereço, o dispositivo escravo correspondente responde com um sinal de ACK para confirmar que foi endereçado corretamente.

4. **Transferência de Dados**: Após o endereçamento, o mestre pode enviar ou receber dados do dispositivo escravo. Durante a transmissão de dados, o mestre envia bytes de dados para o dispositivo escravo, que responde com sinais ACK após a recepção de cada byte.

5. **Stop Condition**: Após concluir a comunicação, o mestre emite uma condição de parada (stop condition), na qual o sinal SDA é colocado de nível lógico baixo para alto enquanto o sinal SCL permanece em alto.

   

   ![i2c.drawio](imgs\i2c.drawio.png)

   

   O mestre é responsável por gerar o clock e controlar a transferência de dados. O escravo é responsável por transmitir ou receber dados do mestre. O reconhecimento dos dados é enviado pelo dispositivo que está recebendo os dados, podendo ser tanto um mestre quanto um escravo. O protocolo I2C também permite que vários mestres residam no barramento I2C.

   Cada escravo possui um endereço único que é determinado pela estrutura do sistema ou pelo dispositivo na linha. Quando um mestre deseja se comunicar com um escravo, o mestre transmite uma condição de START, seguida pelo endereço do escravo e um bit de controle (R/W) para determinar se o mestre deseja transmitir dados ou receber dados do escravo. O escravo então envia um pulso de reconhecimento (ACK) após o endereço.

   Se o mestre (mestre-transmissor) estiver escrevendo para o escravo (escravo-receptor), o receptor recebe um byte de dados. Essa transação continua até que o mestre termine a transmissão com uma condição de STOP. Se o mestre estiver lendo de um escravo (mestre-receptor), o escravo transmite (escravo-transmissor) um byte de dados para o mestre, e o mestre então reconhece a transação com o pulso ACK. Essa transação continua até que o mestre termine a transmissão, e então o mestre emite uma condição de STOP.

   

   ![i2cCOMPORTAMENTO](imgs\i2cCOMPORTAMENTO.png)



## RP2040 / PICO

O RP2040, possui duas interfaces I2C idênticas (I2C0 e I2C1). Ambas são capazes de gerar sinais de clock, iniciar e encerrar comunicações (no modo mestre), apresentam filas de até dezesseis posições para entrada e saída, e suportam o uso de DMA. No modo dispositivo ("slave"), as interfaces podem verificar os endereços e disparar uma interrupção quando uma comunicação do mestre é recebida.

Os pinos do RP2040 utilizados para comunicação I2C são configuráveis. A imagem abaixo apresenta as opções disponíveis:



![picow-I2C-pinout](imgs\picow-I2C-pinout.png)



## SDK

Para usar o PWM você deve modificar o `CMakeLists.txt` adicionando `hardware_adc` no `target_link_libraries`:

```diff
target_link_libraries(
                      ....
                      .....
+                     hardware_adc)
```

E adicionar no headfile:

```c
#include "hardware/adc.h"
```



## Snippets

Códigos exemplo para o ADC.

### Hello ADC

[Simulação no wokwi](https://wokwi.com/projects/392250190334148609){.ah-button}
/
[pico-examples/adc/hello_adc/hello_adc.c](https://github.com/raspberrypi/pico-examples/blob/master/adc/hello_adc/hello_adc.c){.ah-button}

```c
#include <stdio.h>
#include "pico/stdlib.h"
#include "hardware/gpio.h"
#include "hardware/adc.h"

int main() {
    stdio_init_all();
    printf("ADC Example, measuring GPIO27\n");

    adc_init();

    // Make sure GPIO is high-impedance, no pullups etc
    adc_gpio_init(27);
    // Select ADC input 1 (GPIO27)
    adc_select_input(1);

    while (1) {
        // 12-bit conversion, assume max value == ADC_VREF == 3.3 V
        const float conversion_factor = 3.3f / (1 << 12);
        uint16_t result = adc_read();
        printf("Raw value: 0x%03x, voltage: %f V\n", result, result * conversion_factor);
        sleep_ms(500);
    }
}
```


## Referências:

 "Usando I2C na Raspberry Pi Pico com MicroPython e C" Maker Hero. Disponível em: https://www.makerhero.com/blog/usando-i2c-na-raspberry-pi-pico/

"Raspberry Pi Pico (RP2040) I2C Example with MicroPython and C/C++" DigiKey. Disponível em: https://www.digikey.com/en/maker/projects/raspberry-pi-pico-rp2040-i2c-example-with-micropython-and-cc/47d0c922b79342779cdbd4b37b7eb7e2
